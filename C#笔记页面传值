
但是一般来说，常用的较简单有QueryString，Session，Cookies，Application，Server.Transfer。 一、QueryString QueryString是一种非常简单的传值方式，他可以将传送的值显示在浏览器的地址栏中。如果是传递一个或多个安全性要求不高或是结构简单的数值时，可以使用这个方法。但是对于传递数组或对象的话，就不能用这个方法了。 这种方法的优点：1.使用简单，对于安全性要求不高时传递数字或是文本值非常有效。
这种方法的缺点：1.缺乏安全性，由于它的值暴露在浏览器的URL地址中的。
2.不能传递对象。 使用方法：1.在源页面的代码中用需要传递的名称和值构造URL地址。
2.在源页面的代码用Response.Redirect(URL);重定向到上面的URL地址中。
3.在目的页面的代码使用Request.QueryString["name"];取出URL地址中传递的值。 例子：(1)a.aspxprivatevoid Button1_Click(object sender, System.EventArgs e) { string s_url; s_url = "b.aspx?name=" + Label1.Text; Response.Redirect(s_url); } (2)b.aspxprivatevoid Page_Load(object sender, EventArgs e) { Label2.Text = Request.QueryString["name"]; } 二、Session 想必这个肯定是大家使用中最常见的用法了，其操作与Application类似，作用于用户个人，所以，过量的存储会导致服务器内存资源的耗尽。 优点：1.使用简单，不仅能传递简单数据类型，还能传递对象。
2.数据量大小是不限制的。 缺点：1.在Session变量存储大量的数据会消耗较多的服务器资源。 2.容易丢失。 使用方法：1.在源页面的代码中创建你需要传递的名称和值构造Session变量:Session["Name"]="Value(Or Object)"; 2.在目的页面的代码使用Session变量取出传递的值。Result = Session["Nmae"] 注意：session不用时可以销毁它，销毁的方法是：清除一个：Session.Remove("session名"); 清除所有：Session.Clear(); 例子：(1)a.aspxprivatevoid Button1_Click(object sender, System.EventArgs e) { Session["name"] = Label.Text; } (2)b.aspxprivatevoid Page_Load(object sender, EventArgs e) { string name; name = Session["name"].ToString(); } 三、Cookie 这个也是大家常使用的方法，Cookie用于在用户浏览器上存储小块的信息，保存用户的相关信息，比如用户访问某网站时用户的ID，用户的偏好等，用户下次访问就可以通过检索获得以前的信息。所以Cookie也可以在页面间传递值。Cookie通过HTTP头在浏览器和服务器之间来回传递的。Cookie只能包含字符串的值，如果想在Cookie存储整数值，那么需要先转换为字符串的形式。 与Session一样，其是什对每一个用户而言的，但是有个本质的区别，即Cookie是存放在客户端的，而session是存放在服务器端的。而且Cookie的使用要配合ASP.NET内置对象Request来使用。 优点：1.使用简单，是保持用户状态的一种非常常用的方法。比如在购物网站中用户跨多个页面表单时可以用它来保持用户状态。 缺点：1.常常被人认为用来收集用户隐私而遭到批评。 2.安全性不高，容易伪造。 使用方法：1.在源页面的代码中创建你需要传递的名称和值构造Cookie对象:HttpCookie objCookie = new HttpCookie("myCookie","Hello,Cookie!"); Response.Cookies.Add(cookie); 2.在目的页面的代码使用Cookie对象取出传递的值：Result = Request.Cookies[ "myCookie" ].Value; 例子：(1)a.aspxprivatevoid Button1_Click(object sender, System.EventArgs e) { HttpCookie objCookie = new HttpCookie("myCookie","Hello,Cookie!"); Response.Cookies.Add(objCookie); } (2)b.aspxstring myName1Value; myName1Value = Request.Cookies[ "myCookie" ].Value; 四、Application Application对象的作用范围是整个全局，也就是说对所有用户都有效。它在整个应用程序生命周期中都是有效的，类似于使用全局变量一样，所以可以在不同页面中对它进行存取。它和Session变量的区别在于，前者是所有的用户共用的全局变量，后者是各个用户独有的全局变量。 可能有人会问，既然所有用户都可以使用application变量，那他可以用在什么场合呢？这里举个例子：网站访问数。多个请求访问时都可以对它进行操作。 优点：1.使用简单，消耗较少的服务器资源。 2.不仅能传递简单数据，还能传递对象。 3.数据量大小是不限制的。 缺点：1.作为全局变量容易被误操作。所以单个用户使用的变量一般不能用application。 使用方法：1.在源页面的代码中创建你需要传递的名称和值构造Application变量:Application["Nmae"]="Value(Or Object)"; 2.在目的页面的代码使用Application变量取出传递的值。Result = Application["Nmae"] 注意：常用lock和unlock方法用来锁定和解锁，为了防止并发修改。 例子：(1)a.aspxprivatevoid Button1_Click(object sender, System.EventArgs e) { Application["name"] = Label1.Text; } (2)b.aspxprivatevoid Page_Load(object sender, EventArgs e) { string name; Application.Lock(); name = Application["name"].ToString(); Application.UnLock(); } 五、Server.Transfer 这个才可以说是面象对象开发所使用的方法，其使用Server.Transfer方法把流程从当前页面引导到另一个页面中，新的页面使用前一个页面的应答流，所以这个方法是完全面象对象的，简洁有效。 Server.Transfer是从当前的ASPX页面转到新的ASPX页面，服务器端执行新页并输出,在新页面中通过Context.Handler来获得前一个页面传递的各种数据类型的值、表单数据、QueryString.由于重定向完全在服务器端完成，所以客户端浏览器中的URL地址是不会改变的。调用Server.Transfer时，当前的ASPX页面终止执行，执行流程转入另一个ASPX页面，但新的ASPX页面仍使用前一ASPX页面创建的应答流。 ps：比较Server.Transfer和Response.Redirect的区别。 (1)Server.Transfer在服务器端完成，所以客户端浏览器中的URL地址是不会改变的；Response.Redirect是客户端完成，向服务器端提出新的页面处理请求，所以客户端浏览器中的URL地址是会改变的。
(2)Server.Transfer在服务器端完成,不需要客户端提出请求，减少了客户端对服务器端提出请求。[2]
(3)Server.Transfer只能够转跳到本地虚拟目录指定的页面,也就是工程项目中的页面，而Response.Redirect则十分灵活,可以跳转到任何URL地址。
(4)Server.Transfer可以将前一个页面的各种类型的值传到新的页面；Response.Redirect则只能借助URL中带参数或是结合上面四种办法把各种类型的值传到新的页面。 优点：1.直接在服务器端重定向，使用简单方便，减少了客户端对服务器端提出请求。 2.可以传递各种数据类型的值和控件的值。 缺点：1.客户端浏览器中的URL地址是不改变，会导致在新的页面可能出现一些意想不到的问题
